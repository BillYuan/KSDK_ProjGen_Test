#********************************************************************************************
# Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
# All rights reserved.
# #
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
# #
# o Redistributions of source code must retain the above copyright notice, this list
#   of conditions and the following disclaimer.
# #
# o Redistributions in binary form must reproduce the above copyright notice, this
#   list of conditions and the following disclaimer in the documentation and/or
#   other materials provided with the distribution.
# #
# o Neither the name of Freescale Semiconductor, Inc. nor the names of its
#   contributors may be used to endorse or promote products derived from this
#   software without specific prior written permission.
# #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Description: Automation test for KSDK project generator tool for SDK 1.3,
# need copy it to test\ folder.
#
# Revision History:
# -----------------
# Code Version    YYYY-MM-DD    Author        Description
# 0.1             2015-09-02    Bill Yuan     Create this file
#********************************************************************************************

import os
import sys
import inspect
import unittest
from Tkinter import *
from ttk import *

import sys
import os
import platform
import re
import _winreg
import shutil
import time

#add the src
cmd_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe()))[0], os.pardir, "src")))
if cmd_folder not in sys.path:
    sys.path.insert(0, cmd_folder)

from ksdkGUI import PgGui, PGKSDK_VERSION, PGKSDK_NAME
import ksdkGUI as kGUI
import ksdkImg as kImg
import xml.etree.ElementTree as ET

DEBUG = False
DEBUG_SLOW = False
# QUICK_TEST is used to only test one board/device/demo(for clone)
# If set it as "False", it will loop all combination and will take long time, you'd better prepare your disk space.
QUICK_TEST = True

# AUTO_VERIFICATION is used to auto check the projects that generated by this tool, check whether the CPU type is correct
AUTO_VERIFICATION = True

# SDK_PATH need adjust according to your PC environment
SDK_PATH = 'C:\\Freescale\\SDK_1.3.0_MK81FN256xxx15_win_RC3.3'


# timeout for each project creating
TIME_OUT = 15 # seconds

# some platforms do not support the RTOS, skip generate them
RTOS_NOT_AVAIBLE_LIST = ('FRDM-KL02Z', 'FRDM-KL03Z', 'FRDM-KV10Z', 'TWR-KM34Z75M', 'TWR-KV10Z32')

# global define
PROJECT_PRE = 'myProject_'

TEMP_QUICK_FOLDER = 'user_apps'
TEMP_ADVANCE_FOLDER = 'user_projects'

dict_board_cpu = {}
dict_device_cpu = {}

dict_os_lib = {'lib_rtos_none'      : 'ksdk_platform_lib',
               'lib_rtos_mqx'       : 'ksdk_mqx_lib',
               'lib_rtos_freertos'  : 'ksdk_freertos_lib',
               'lib_rtos_ucosii'    : 'ksdk_ucosii_lib',
               'lib_rtos_ucosiii'   : 'ksdk_ucosiii_lib' }

# clean the test environment, remove all generated projects
def clean_env():
    if DEBUG: print 'clean the test environment, remove all generated projects'

    temp_advance_folder = os.path.join(SDK_PATH, TEMP_ADVANCE_FOLDER)
    if os.path.isdir(temp_advance_folder):
        print 'cleaning folder ' + temp_advance_folder
        shutil.rmtree(temp_advance_folder)

    temp_quick_root = os.path.join(SDK_PATH, 'examples')
    if os.path.isdir(temp_quick_root):
        for item_level1 in os.listdir(temp_quick_root):
            for item_level2 in os.listdir(os.path.join(temp_quick_root, item_level1)):
                if re.match(TEMP_QUICK_FOLDER, item_level2):
                    print 'cleaning folder ' + os.path.join(os.path.join(temp_quick_root, item_level1), item_level2)
                    shutil.rmtree(os.path.join(os.path.join(temp_quick_root, item_level1), item_level2))


def load_manifest():
    tree = ET.parse(SDK_PATH + '/ksdk_manifest.xml')
    root = tree.getroot()
    for boards in root.findall('boards'):
        for board in boards:
            board_name = board.get('user_name')
            default_cpu_name = board.get('package')
            dict_board_cpu[board_name] = default_cpu_name

    for devices in root.findall('devices'):
        for device in devices:
            device_name = device.get('full_name')
            for dev_package in device.findall('package'):
                dev_package_name = dev_package.get('name') # just use the first name
                dict_device_cpu[device_name] = dev_package_name
                break

    if DEBUG:
        print 'load_manifest: '
        print dict_board_cpu
        print dict_device_cpu


class TestChooseBoard(unittest.TestCase):
    def setUp(self):
        """ Main file for KSDK Project Generator
        .. todo::
          test on Linux, OSX
        .. todo::
        go over comments for documentation; params, etc...
        """

        osName = platform.system()
        root = Tk()                                                # Call Tkinter object 'root'
        s = Style()

        # Set ttk style for the OS
        if osName == 'Linux':
            s.theme_use('alt')
        elif osName == 'Windows':
            s.theme_use('vista')
        elif osName == 'Darwin':
            s.theme_use('aqua')

        if osName == 'Windows':                                     # Check if running on Windows
            try:
                root.iconbitmap(default='./kds_icon.ico')           # Use the .ico file if in Windows
            except TclError:
                root.iconbitmap(default=None)
        elif osName == 'Linux':
            img = Image("photo", data=kImg.boardImages['kds_icon.gif']) # Use the .gif file if in Linux
            root.tk.call('wm', 'iconphoto', root._w, img)

        root.title(PGKSDK_NAME + ' -- ' + PGKSDK_VERSION)   # Set title of Tkinter window

        if osName == 'Darwin':
            root.configure(background='#E7E7E7')

        screenWidth = root.winfo_screenwidth()
        screenHeight = root.winfo_screenheight()

        if osName == 'Windows':

            key = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, "Control Panel\\Desktop\\WindowMetrics")
            value = _winreg.QueryValueEx(key, "AppliedDPI")[0]

            print "DPI value: " + str(value)

            if value == 96:
                kGUI.WIN_SCALE = 1.0
            elif value == 120:
                kGUI.WIN_SCALE = 1.25
            elif value == 144:
                kGUI.WIN_SCALE = 1.5
            elif value == 192:
                kGUI.WIN_SCALE = 2.0
            else:
                kGUI.WIN_SCALE = value / 96.0

            print "DPI scale: " + str(kGUI.WIN_SCALE)

            windowWidth = (570 * kGUI.WIN_SCALE)
            windowHeight = (420 * kGUI.WIN_SCALE)

            # Get x & y location for centering the window
            xLocation = screenWidth / 2 - windowWidth / 2
            yLocation = screenHeight / 2 - windowHeight / 2

            root.geometry('%dx%d+%d+%d' % (windowWidth, windowHeight, xLocation, yLocation))
        elif osName == 'Linux':

            windowWidth = 605
            windowHeight = 420

            # Get x & y location for centering the window
            xLocation = screenWidth / 2 - windowWidth / 2
            yLocation = screenHeight / 2 - windowHeight / 2

            root.geometry('%dx%d+%d+%d' % (windowWidth, windowHeight, xLocation, yLocation))
        else:

            windowWidth = 620
            windowHeight = 480

            # Get x & y location for centering the window
            xLocation = screenWidth / 2 - windowWidth / 2
            yLocation = screenHeight / 2 - windowHeight / 2

            root.geometry('%dx%d+%d+%d' % (windowWidth, windowHeight, xLocation, yLocation))

        root.resizable(width=FALSE, height=FALSE)
        self.root = root
        self.app = PgGui(master=root)

        self.app.localSDK.path = SDK_PATH # we have force to set the path because of script issue

        #fix the sdk path not effect issue
        self.app.pop_main_boards()

        #first step is to launch the main ui
        self.prepare_main_ui_dict()

        #set SDK root path
        w_ksdk_path = self.dict_main_widgets['ksdk_path']
        w_ksdk_path.delete(0, END)
        w_ksdk_path.insert(0, SDK_PATH)


    def tearDown(self):
        #need destroy the window, otherwise the next case cannot setUp successfully
        if DEBUG: print 'tearDown, destroy the window successfully'
        self.root.destroy()


    def prepare_main_ui_dict(self):
        if DEBUG: print 'prepare_main_ui_dict'

        main_widigets = {'ksdk_path'        : self.app.widgetList[1],
                         'project_name'     : self.app.widgetList[4],
                         'choose_board'     : self.app.widgetList[6],
                         'advanced'         : self.app.widgetList[11],
                         'quick_generate'   : self.app.widgetList[10],
                         }
        self.dict_main_widgets = main_widigets


    def prepare_advance_ui_dict(self):
        if DEBUG: print "prepare_advance_ui_dict"

        ad_widgets = {'project_name'        : self.app.widgetList[3],
                      'device_or_board_list': self.app.widgetList[8],
                      'project_type_new'    : self.app.widgetList[5], #0
                      'project_type_clone'  : self.app.widgetList[6], #1
                      'lib_config_platform' : self.app.widgetList[11], #1
                      'lib_config_hal'      : self.app.widgetList[10], #0
                      'lib_rtos_none'       : self.app.widgetList[13], #0
                      'lib_rtos_mqx'        : self.app.widgetList[14], #1
                      'lib_rtos_freertos'   : self.app.widgetList[15], #2
                      'lib_rtos_ucosii'     : self.app.widgetList[16], #3
                      'lib_rtos_ucosiii'    : self.app.widgetList[17], #4
                      'choose_device'       : self.app.widgetList[35], #0
                      'choose_board'        : self.app.widgetList[36], #1
                      'tool_kds'            : self.app.widgetList[19],
                      'tool_iar'            : self.app.widgetList[20],
                      'tool_mdk'            : self.app.widgetList[21],
                      'tool_atl'            : self.app.widgetList[22],
                      #'tool_gcc'            : self.app.widgetList[23], #remove by default
                      'include_bsp'         : self.app.widgetList[25],
                      'parent_folder'       : self.app.widgetList[27],
                      'standalone'          : self.app.widgetList[29],
                      'advance_generate'    : self.app.widgetList[31],
                     }

        self.dict_ad_widgets = ad_widgets


    def test_quick_generate(self):
        #get the list boards
        w_choose_board = self.dict_main_widgets['choose_board']
        list_items = w_choose_board.get(0, END)
        if DEBUG: print list_items

        #select and quick generate the boards one by one
        boards_num = len(list_items)
        index = 0
        while (index < boards_num):
            #clear the selection
            if index > 0:
                w_choose_board.selection_clear(index - 1 )

            w_choose_board.selection_set(index)
            self.app.update()

            new_project_name = PROJECT_PRE + w_choose_board.selection_get() + "_quick"
            print '-quick generate: --board:' + list_items[index] + " --project_name:" + new_project_name

            self.set_project_name(self.dict_main_widgets['project_name'], new_project_name)

            # need update the widget before the invoke
            self.prepare_main_ui_dict()
            self.dict_main_widgets['quick_generate'].invoke()
            self.app.update()

            self.wait_and_destroy_pop_gen()

            if AUTO_VERIFICATION:
                folder_root = SDK_PATH + '\\examples\\' + self.lowercase_removeothers(list_items[index]) + '\\user_apps\\' + new_project_name
                self.verify_quick_projects(list_items[index], folder_root)

            if QUICK_TEST: break    # only test one board in quick test

            index += 1


    def set_project_name(self, name_wdiget, new_name):
        name_wdiget.delete(0, END)
        name_wdiget.insert(0, new_name.rstrip())


    def wait_and_destroy_pop_gen(self):
        # Need patch to the ksdkGUI.py
        timeout = 0
        while (None == self.app.pop_gen and timeout < TIME_OUT):
            print 'waiting until pop up gen window... '
            time.sleep(1)
            timeout = timeout + 1

        if DEBUG_SLOW: time.sleep(2)
        if self.app.pop_gen != None:
            self.app.pop_gen.destroy()
            self.app.pop_gen = None
        else:
            print "Time out in waiting gen window !!!!"


    def lowercase_removeothers(self, platform_name):
        platform_path_name = platform_name.replace('-', '').rstrip().lower()
        if DEBUG: print 'lowercase_removeothers: ' + platform_name + ' --- ' + platform_path_name
        return platform_path_name


    def verify_quick_projects(self, platform_name, project_root):
        if DEBUG: print 'verify_quick_project: ' + platform_name + ', ' + project_root
        self.verify_project_iar(platform_name, project_root)
        self.verify_project_kds(platform_name, project_root)
        self.verify_project_mdk(platform_name, project_root)
        self.verify_project_atl(platform_name, project_root)
        #self.verify_project_armgcc(platform_name, project_root)


    def verify_project_iar(self, name, project_root):
        self.verify_project_file("iar", ".+\.ewp$", self.get_cpu_serach_key(name), project_root)


    def verify_project_kds(self, name, project_root):
        self.verify_project_file("kds", "\.cproject$", self.get_cpu_serach_key(name), project_root)


    def verify_project_mdk(self, name, project_root):
        self.verify_project_file("mdk", ".+\.uvprojx$", self.get_cpu_serach_key(name), project_root)


    def verify_project_atl(self, name, project_root):
        self.verify_project_file("atl", "\.cproject$", self.get_cpu_serach_key(name), project_root)


    def verify_project_armgcc(self, name, project_root):
        self.verify_project_file("armgcc", "CMakeLists.txt$", self.get_cpu_serach_key(name), project_root)


    def get_cpu_serach_key(self, name):
        search_key = ''
        if re.search('xxx', name): # it's device name
            search_key = 'CPU_' + dict_device_cpu[name]
        else: # it's board name
            search_key = 'CPU_' + dict_board_cpu[name]

        if DEBUG: print "search key: " + search_key

        return search_key


    def verify_project_file(self, toolchain, file_name_reg, search_key, folder_root):
        folder_root = folder_root + "\\" + toolchain + "\\"
        self.assertEqual(os.path.exists(folder_root), True, "Didn't generate " + toolchain + " project folder: " + folder_root)
        is_found = False
        for item in os.listdir(folder_root):
            if DEBUG: print item
            if re.match(file_name_reg, item):
                is_found = True
                project_file = open(os.path.join(folder_root, item))
                if DEBUG: print "project file: " + os.path.join(folder_root, item)
                content = project_file.readlines()
                project_file.close()

                is_match_key = False
                for line in content:
                    #if DEBUG: print line
                    if re.search(search_key, line):
                        is_match_key = True
                        break

                self.assertNotEqual(is_match_key, False, "Wrong project file generated, the platform name does not match " + search_key + " in " + os.path.join(folder_root, item))
                break

        self.assertNotEqual(is_found, False, "Didn't find the project file in: " + folder_root)


    def test_advance_platform_boards_all_toolchains(self):
        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_new'].invoke()
        self.dict_ad_widgets['choose_board'].invoke()
        self.dict_ad_widgets['lib_config_platform'].invoke()
        self.app.update()

        self.new_all_toolchains(False, False)


    def test_advance_platform_device_all_toolchains(self):
        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_new'].invoke()
        self.dict_ad_widgets['choose_device'].invoke()
        self.dict_ad_widgets['lib_config_platform'].invoke()
        self.app.update()

        self.new_all_toolchains(True, False)


    def test_advance_hal_boards_all_toolchains(self):
        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_new'].invoke()
        self.dict_ad_widgets['choose_board'].invoke()
        self.dict_ad_widgets['lib_config_hal'].invoke()
        self.app.update()

        self.new_all_toolchains(False, True)


    def test_advance_hal_device_all_toolchains(self):
        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_new'].invoke()
        self.dict_ad_widgets['choose_device'].invoke()
        self.dict_ad_widgets['lib_config_hal'].invoke()
        self.app.update()

        self.new_all_toolchains(True, True)


    def new_all_toolchains(self, addition_apply, hal_only):
        w_device_or_board = self.dict_ad_widgets['device_or_board_list']
        boards_list =  w_device_or_board['values']
        if DEBUG: print boards_list

        #select all toolchains and bsp
        self.dict_ad_widgets['tool_kds'].invoke()
        self.dict_ad_widgets['tool_iar'].invoke()
        self.dict_ad_widgets['tool_mdk'].invoke()
        self.dict_ad_widgets['tool_atl'].invoke()
        #self.dict_ad_widgets['tool_gcc'].invoke()
        self.app.update()

        hal_name_pre = ''
        if hal_only:
            hal_name_pre = 'hal_'

        #loop boards
        board_index = 0
        boards_num = len(boards_list)
        while (board_index < boards_num):
            if DEBUG: print 'board index is : %d', board_index
            w_device_or_board.current(newindex=board_index)

            #loop standalone
            for include_standalone in range(0, 2):
                standalone_name = self.update_checkbox('standalone', include_standalone, '_st_')

                # need reset the device or board selection after changing the rtos setting
                w_device_or_board.current(newindex=board_index)
                self.app.update()

                #loop rtos
                for os_name in ['lib_rtos_none', 'lib_rtos_mqx', 'lib_rtos_freertos', 'lib_rtos_ucosii', 'lib_rtos_ucosiii']:
                    self.dict_ad_widgets[os_name].invoke()
                    self.app.update()

                    # need reset the device or board selection after changing the rtos setting
                    w_device_or_board.current(newindex=board_index)
                    self.app.update()

                    #some SoCs don't support RTOS, skip to generate the projects
                    if os_name != 'lib_rtos_none' and w_device_or_board.get() in RTOS_NOT_AVAIBLE_LIST: continue

                    if False == hal_only and 'lib_rtos_none' == os_name:
                        bsp_loop_count = 2
                    else:
                        bsp_loop_count = 1

                    #loop bsp
                    for include_bsp in range(0, bsp_loop_count):
                        bsp_name = self.update_checkbox('include_bsp', include_bsp, '_bsp_')

                        # mux the project_name
                        project_name = PROJECT_PRE + hal_name_pre + w_device_or_board.get() + '_' + standalone_name + bsp_name + os_name
                        #update project name
                        self.set_project_name(self.dict_ad_widgets['project_name'], project_name)

                        print '-advance generate: ---board:' + boards_list[board_index] + '  ---project_name:' + project_name

                        # need update the widget before the invoke
                        self.prepare_advance_ui_dict()
                        self.dict_ad_widgets['advance_generate'].invoke()
                        self.app.update()

                        if addition_apply:
                            self.wait_and_destory_pop_package()

                        self.wait_and_destroy_pop_gen()

                        if AUTO_VERIFICATION:
                            folder_root = SDK_PATH + '\\user_projects\\' + project_name
                            self.verify_adv_projects(hal_only, include_standalone, include_bsp, os_name, boards_list[board_index], folder_root)

                    # RTOS does not support hal lib
                    if hal_only or addition_apply:
                        break   # break the rtos loop

            if QUICK_TEST: break    # only test one board in quick test

            board_index += 1

    def update_checkbox(self, checkbox_name, select, intial_name):
        default_name = ''
        if select:
            default_name = intial_name
            if len(self.dict_ad_widgets[checkbox_name].state()) <= 0:
                self.dict_ad_widgets[checkbox_name].invoke()
        else:
            if len(self.dict_ad_widgets[checkbox_name].state()) > 0:
                self.dict_ad_widgets[checkbox_name].invoke()

        self.app.update()

        return default_name


    def wait_and_destory_pop_package(self):
        # Need patch to the ksdkGUI.py
        timeout = 0
        while (None == self.app.pop_package and timeout < TIME_OUT):
            # wait until pop package window is ready
            print 'waiting until pop up package window ...'
            time.sleep(1)
            timeout = timeout + 1

        if DEBUG_SLOW: time.sleep(2)

        if None == self.app.pop_package:
            print "Time out in waiting pop up package window !!!"

        self.app.begin_advanced_gen(self.app, self.app.pop_package)
        self.app.update()
        self.app.pop_package = None

    def verify_adv_projects(self, hal_only, include_standalone, include_bsp, os_name, board_or_device, project_root):
        if hal_only:
            # only iar and keil has lib link
            self.verify_project_file("iar", ".+\.eww$", "ksdk_hal_lib", project_root)
            self.verify_project_file("mdk", ".+\.uvprojx$", "ksdk_hal_lib", project_root)
        else:
            # platform link
            self.verify_project_file("iar", ".+\.eww$", dict_os_lib[os_name], project_root)
            self.verify_project_file("mdk", ".+\.uvprojx$", dict_os_lib[os_name], project_root)

        # check the standalone
        self.verify_standalone(hal_only, include_standalone, os_name, project_root)

        # check the bsp, the RTOS includes the bsp file by default
        if 'lib_rtos_mqx' == os_name or 'lib_rtos_freertos' == os_name or 'lib_rtos_ucosii' == os_name or 'lib_rtos_ucosiii' == os_name or include_bsp:
            self.assertEqual(os.path.exists(os.path.join(project_root, 'board')), True, 'bsp folder does not include in ' + project_root)
        else:
            self.assertEqual(os.path.exists(os.path.join(project_root, 'board')), False, 'bsp folder should not include in ' + project_root)

        # don't verify armgcc so far, because it does not support
        self.verify_project_iar(board_or_device, project_root)
        self.verify_project_kds(board_or_device, project_root)
        self.verify_project_mdk(board_or_device, project_root)
        self.verify_project_atl(board_or_device, project_root)

    def verify_standalone(self, hal_only, include_standalone, os_name, folder_root):
        # check the standalone
        if include_standalone:
            self.assertEqual(os.path.exists(os.path.join(folder_root, 'lib')), True, 'lib does not include in ' + folder_root)
            self.assertEqual(os.path.exists(os.path.join(folder_root, 'platform')), True, 'platform does not include in ' + folder_root)

            is_found_lib = False
            for dir_name in os.listdir(os.path.join(folder_root, 'lib')):
                if hal_only:
                    if 'ksdk_hal_lib' == dir_name:
                        is_found_lib = True
                        break
                else:
                    if dict_os_lib[os_name] == dir_name:
                        is_found_lib = True
                        break
            self.assertEqual(is_found_lib, True)

        else:
            self.assertEqual(os.path.exists(os.path.join(folder_root, 'lib')), False, 'lib should not include in ' + folder_root)
            self.assertEqual(os.path.exists(os.path.join(folder_root, 'platform')), False, 'platform should not include in ' + folder_root)

    def test_advance_singal_toolchain_iar(self):
        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()
        self.new_singal_toolchain('tool_iar')


    def test_advance_singal_toolchain_kds(self):
        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()
        self.new_singal_toolchain('tool_kds')


    def test_advance_singal_toolchain_atl(self):
        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()
        self.new_singal_toolchain('tool_atl')


    def test_advance_singal_toolchain_mdk(self):
        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()
        self.new_singal_toolchain('tool_mdk')


    def new_singal_toolchain(self, toolchain):

        # only check one board
        self.dict_ad_widgets['choose_board'].invoke()
        self.dict_ad_widgets[toolchain].invoke()
        self.app.update()

        #loop standalone
        for include_standalone in range(0, 2):
            standalone_name = self.update_checkbox('standalone', include_standalone, '_st_')

            # loop os
            for os_name in ['lib_rtos_none', 'lib_rtos_mqx', 'lib_rtos_freertos', 'lib_rtos_ucosii', 'lib_rtos_ucosiii']:
                self.dict_ad_widgets[os_name].invoke()
                self.app.update()

                name = self.dict_ad_widgets['device_or_board_list'].get()
                project_name = PROJECT_PRE  + toolchain + '_' + name + '_' + standalone_name + os_name
                self.set_project_name(self.dict_ad_widgets['project_name'], project_name)

                # need update the widget before the invoke
                self.prepare_advance_ui_dict()
                self.dict_ad_widgets['advance_generate'].invoke()
                self.app.update()

                self.wait_and_destroy_pop_gen()

                if AUTO_VERIFICATION:
                    folder_root = SDK_PATH + '\\user_projects\\' + project_name
                    self.verify_singal_toolchain_projects(include_standalone, os_name, toolchain, name, folder_root)


    def verify_singal_toolchain_projects(self, include_standalone, os_name, toolchain, name, folder_root):
        self.verify_standalone(False, include_standalone, os_name, folder_root)

        self.assertEqual(os.path.exists(os.path.join(folder_root, 'iar')), 'tool_iar' == toolchain)
        self.assertEqual(os.path.exists(os.path.join(folder_root, 'mdk')), 'tool_mdk' == toolchain)
        self.assertEqual(os.path.exists(os.path.join(folder_root, 'atl')), 'tool_atl' == toolchain)
        self.assertEqual(os.path.exists(os.path.join(folder_root, 'kds')), 'tool_kds' == toolchain)

        if 'tool_iar' == toolchain:
            self.verify_project_iar(name, folder_root)

        if 'tool_mdk' == toolchain:
            self.verify_project_mdk(name, folder_root)

        if 'tool_atl' == toolchain:
            self.verify_project_atl(name, folder_root)

        if 'tool_kds' == toolchain:
            self.verify_project_kds(name, folder_root)


    def test_advance_clone(self):
        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_clone'].invoke()
        self.app.update()

        w_demos = self.app.widgetList[36]
        demo_list = w_demos['values']
        if DEBUG: print demo_list

        #loop boards
        demo_index = 0
        demo_num = len(demo_list)
        while (demo_index < demo_num):
            if DEBUG: print 'demo index is : %d', demo_index
            w_demos.current(newindex=demo_index)
            self.app.update()

            #loop standalone
            for include_standalone in range(0, 2):
                self.update_checkbox('standalone', include_standalone, '_st_')
                self.app.update()

                if DEBUG_SLOW: time.sleep(1)

                # need update the widget before the invoke
                self.prepare_advance_ui_dict()
                self.dict_ad_widgets['advance_generate'].invoke()
                self.app.update()

                self.wait_and_destroy_pop_gen()

            if QUICK_TEST: break    # only test one board in quick test

            demo_index += 1

if __name__ == '__main__':
    clean_env()
    if AUTO_VERIFICATION: load_manifest()
    unittest.main()
